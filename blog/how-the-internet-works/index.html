<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How the internet works? - Kavya Sahai</title>
    <link rel="stylesheet" href="/style.css"> <!-- Link to your main CSS file -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="container">
            <a href="../"><h1>Full Stack Development Course</h1></a>
             <p>Learn with us for free</p>
        </div>
    </header>

    <div class="container blog-post-container">
        <aside class="blog-toc">
            <h3>Table of Contents</h3>
            <ul id="toc">
               <!-- Table of contents will be automatically generated by JavaScript -->
            </ul>
        </aside>

        <main class="blog-content">
            <h1 id="post-title">How does the Internet Work?</h1>
             <!-- Actual blog content starts here -->
             <p>Ever wonder what happens when you click a link? üåê How The Internet Works takes you behind the scenes of the digital world, breaking down complex tech into simple, bite-sized insights. From data packets to servers and beyond, discover the magic that powers your online experience! (Hook written with the help of AI, because I can&#39;t :D)</p>
             <h2 id="what-happens-when-you-go-to-google-com-">What happens when you go to google.com?</h2>
             <h3 id="the-g-key-is-pressed">The &quot;g&quot; key is pressed</h3>
             <p>Let me explain the physical keyboard actions and the OS interrupts. When you press the &quot;g&quot; key, the browser registers the event, triggering the auto-complete functions. Based on your browser&#39;s algorithm and whether you&#39;re in regular or private/incognito mode, various suggestions appear in a dropdown beneath the URL bar. </p>
             <p>These suggestions are typically prioritized and sorted using factors such as your search history, bookmarks, cookies, and popular internet searches. As you continue typing &quot;google.com,&quot; numerous processes run in the background, and the suggestions refine with each keystroke. The browser might even predict &quot;google.com&quot; before you&#39;ve finished typing.</p>
             <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rtn7jmyysay7wvwalqi6.png" alt="Autocomplete Sequence">
             Browsing Autocomplete Sequences</p>
             <p>The &quot;enter&quot; key bottoms out</p>
             <p>To establish a starting point, let&#39;s consider the Enter key on a keyboard when it reaches the bottom of its travel range. At this moment, an electrical circuit dedicated to the Enter key is closed (either mechanically or capacitively), allowing a small current to flow into the keyboard&#39;s logic circuitry. This circuitry scans the state of each key switch, filters out electrical noise from the rapid closure of the switch (debouncing), and translates the action into a keycode‚Äîin this case, the integer 13. The keyboard controller then encodes this keycode for transmission to the computer. Today, this is almost always done over a Universal Serial Bus (USB) or Bluetooth connection, though older systems used PS/2 or ADB.</p>
             <p><strong>In the case of a USB keyboard</strong>:</p>
             <ul>
             <li>The keyboard is powered by a 5V supply delivered through pin 1 of the computer&#39;s USB host controller.</li>
             <li>The keycode generated by the keypress is stored in an internal register known as the &quot;endpoint.&quot;</li>
             <li>The USB host controller polls this &quot;endpoint&quot; roughly every 10ms (the minimum interval set by the keyboard), retrieving the stored keycode.</li>
             <li>The keycode is sent to the USB Serial Interface Engine (SIE), where it is converted into one or more USB packets in accordance with the USB protocol.</li>
             <li>These packets are transmitted over the D+ and D- lines (the two middle pins) at a maximum rate of 1.5 Mb/s, as the keyboard is classified as a &quot;low-speed device&quot; (per USB 2.0 standards).</li>
             <li>The computer&#39;s host USB controller decodes this serial signal, and the Human Interface Device (HID) driver interprets the keypress. Finally, the key event is passed to the operating system&#39;s hardware abstraction layer.
             <img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/9c2odnfsch9tdg4hazt0.png" alt="Sequence Diagram in case of USB Keyboard">
             Sequence Diagram</li>
             </ul>
             <p><strong>In the case of a virtual keyboard (such as on touch screen devices)</strong>:</p>
             <ul>
             <li>When the user touches a capacitive touch screen, a small amount of current transfers to their finger. This interaction disturbs the electrostatic field of the screen‚Äôs conductive layer, creating a voltage drop at the point of contact.</li>
             <li>The screen controller detects this and triggers an interrupt, reporting the coordinates of the touch.</li>
             <li>The operating system then alerts the currently active application that a press event has occurred within its graphical interface, typically on a virtual keyboard button.</li>
             <li>The virtual keyboard application raises a software interrupt, which notifies the operating system of a &quot;key pressed&quot; event.</li>
             <li>The focused application receives this notification and processes the keypress accordingly.
             <img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m2id13v4a4q35x8mb7s7.png" alt="Sequence Diagram in case of a Virtual Keyboard.">
             Sequence Diagram Describing the same</li>
             </ul>
             <h3 id="interrupt-fires-not-for-usb-keyboards-">Interrupt Fires [Not for USB Keyboards]</h3>
             <p>For non-USB keyboards, such as those using legacy connections (e.g., PS/2), the keyboard signals an interrupt via its interrupt request line (IRQ). This IRQ is mapped to an interrupt vector (an integer) by the system&#39;s interrupt controller. The CPU consults the Interrupt Descriptor Table (IDT), which links each interrupt vector to a corresponding function known as an interrupt handler, supplied by the operating system‚Äôs kernel.</p>
             <p>When the interrupt is triggered, the CPU uses the interrupt vector to index into the IDT and execute the appropriate interrupt handler. This process causes the CPU to transition into kernel mode, allowing the operating system to manage the keypress event.</p>
             <h3 id="a-wm_keydown-message-is-sent-to-the-app-on-windows-">A WM_KEYDOWN Message is Sent to the App (On Windows)</h3>
             <p>When the Enter key is pressed, the Human Interface Device (HID) transport passes the key down event to the KBDHID.sys driver, which converts the HID usage data into a scan code. In this case, the scan code is VK_RETURN (0x0D), representing the Enter key. The KBDHID.sys driver then communicates with the KBDCLASS.sys driver (the keyboard class driver), which securely manages all keyboard input. Before proceeding, the signal may pass through any third-party keyboard filters installed on the system, though this also happens in kernel mode.</p>
             <p>Next, Win32K.sys comes into play, determining which window is currently active by invoking the GetForegroundWindow() API. This function retrieves the window handle (hWnd) of the active application, such as the browser‚Äôs address bar. At this point, the Windows &quot;message pump&quot; calls SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam). The lParam parameter contains a bitmask that provides additional information about the keypress, including:</p>
             <ul>
             <li><strong>Repeat count</strong> (which is 0 in this case),</li>
             <li><strong>Scan code</strong> (which might be OEM-specific but typically standard for VK_RETURN),</li>
             <li><strong>Extended key flags</strong> (indicating whether modifier keys like Alt, Shift, or Ctrl were also pressed, which they weren‚Äôt).</li>
             </ul>
             <p>The SendMessage API queues the message for the specific window handle. Later, the system‚Äôs main message processing function (known as WindowProc) assigned to the window (hWnd) retrieves and processes messages in the queue.</p>
             <p>The active window in this case is an edit control, and its WindowProc function has a message handler that responds to WM_KEYDOWN events. The handler checks the third parameter (wParam) passed by SendMessage, recognizes that the value is VK_RETURN, and thus determines that the user has pressed the Enter key. This triggers the appropriate response for the application.</p>
             <h3 id="a-keydown-nsevent-is-sent-to-the-app-on-os-x-">A KeyDown NSEvent is Sent to the App (On OS X)</h3>
             <p>When a key is pressed on OS X, the interrupt signal triggers an event in the I/O Kit keyboard driver (a kernel extension or &quot;kext&quot;). This driver translates the hardware signal into a key code. The key code is then passed to the <strong>WindowServer</strong>, which manages the graphical user interface.</p>
             <p>The <strong>WindowServer</strong> dispatches the key press event to the appropriate applications (such as the active or listening ones) by sending it through their <strong>Mach port</strong>, where it is placed into an event queue. Applications with the proper privileges can access this event queue by calling the <code>mach_ipc_dispatch</code> function.</p>
             <p>Most applications handle this process through the NSApplication main event loop, which is responsible for processing user input. When the event is a key press, it is represented as an NSEvent of type NSEventTypeKeyDown. The application then reads this event and responds accordingly, triggering any code related to keypress actions based on the key code received.</p>
             <h3 id="the-xorg-server-listens-for-keycodes-on-gnu-linux-">The Xorg Server Listens for Keycodes (On GNU/Linux)</h3>
             <p>When a key is pressed in a graphical environment using the X server, the X server employs the <strong>evdev</strong> (event device) driver to capture the keypress event. The keycode from the physical keyboard is then re-mapped into a <strong>scancode</strong> using X server-specific keymaps and rules.</p>
             <p>Once the mapping is complete, the X server forwards the resulting <strong>scancode</strong> to the <strong>window manager</strong> (such as DWM, Metacity, i3, etc.). The window manager, in turn, sends the character or key event to the currently focused window. The <strong>graphical API</strong> of the focused window processes this event and displays the corresponding symbol in the appropriate field, using the correct font, based on the key pressed.</p>
             <p>This flow ensures that the character is correctly rendered in the active application‚Äôs interface, completing the keypress interaction from hardware to graphical output.</p>
             <h3 id="parse-url">Parse URL</h3>
             <p>When the browser parses the URL(Uniform Resource Locator), it extracts the following components:</p>
             <ul>
             <li>Protocol: <code>&quot;http&quot;</code>
             The browser understands that this uses the Hyper Text Transfer Protocol to communicate with the server.</li>
             <li>Resource: <code>&quot;/&quot;</code>
             This indicates that the browser should retrieve the main (index) page of the website, as the <code>/</code> path typically refers to the root or home page of the server.</li>
             </ul>
             <p>Each of these components helps the browser interpret and fetch the desired resource from the web.</p>
             <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/78ybjwioh3fcmnzztt7m.png" alt="URL Parsing"></p>
             <h3 id="is-it-a-url-or-a-search-term-">Is it a URL or a Search Term?</h3>
             <p>When no protocol (e.g., &quot;http&quot;) or valid domain name is provided, the browser interprets the text in the address bar as a potential search term. Instead of trying to resolve it as a URL, the browser forwards the text to its default web search engine.</p>
             <p>In most cases, the browser appends a special identifier to the search query, indicating that the request originated from the browser&#39;s URL bar. This allows the search engine to handle and prioritize these searches accordingly, improving the relevance of the results based on the context.</p>
             <p>This process helps the browser determine whether it should attempt to navigate directly to a website or provide search results based on the entered text.</p>
             <h3 id="convert-non-ascii-unicode-characters-in-the-hostname">Convert Non-ASCII Unicode Characters in the Hostname</h3>
             <ul>
             <li>The browser examines the hostname for any characters that fall outside the ASCII range, specifically those that are not in the sets of a-z, A-Z, 0-9, -, or ..</li>
             <li>In this case, the hostname is google.com, which contains only ASCII characters, so no conversion is necessary. However, if there were non-ASCII characters present in the hostname, the browser would apply Punycode encoding to convert the hostname into a valid ASCII representation. This process ensures that all characters in the hostname can be correctly processed by the network protocols.</li>
             </ul>
             <h3 id="check-hsts-list">Check HSTS List</h3>
             <p>The browser first checks its preloaded <strong>HSTS (HTTP Strict Transport Security)</strong> list, which contains websites that have explicitly requested to be accessed only via <strong>HTTPS</strong>.</p>
             <p>If the requested website is found on this list, the browser automatically sends the request using <strong>HTTPS</strong> rather than <strong>HTTP</strong>. If the website is not in the HSTS list, the initial request is sent via <strong>HTTP</strong>.</p>
             <p>It‚Äôs important to note that a website can still implement HSTS without being included in the preloaded list. In such cases, the first <strong>HTTP</strong> request made by the user will return a response instructing the browser to only send subsequent requests via <strong>HTTPS</strong>. However, this initial <strong>HTTP</strong> request could expose the user to a <a href="https://venafi.com/blog/what-are-ssl-stripping-attacks/">downgrade attack</a>, where an attacker might intercept the request and force it to remain unencrypted. This vulnerability is why modern web browsers include the HSTS list, enhancing security for users by preventing insecure connections from being established in the first place.</p>
             <h3 id="dns-lookup">DNS Lookup</h3>
             <p>The browser begins the DNS lookup process by checking if the domain is already present in its cache. (To view the DNS cache in Google Chrome, navigate to <code>chrome://net-internals/#dns</code>.)</p>
             <p>If the domain is not found in the cache, the browser calls the <code>gethostbyname</code> library function (the specific function may vary depending on the operating system) to perform the hostname resolution.</p>
             <ol>
             <li><p>Local Hosts File Check:</p>
             <ul>
             <li>The <code>gethostbyname</code> function first checks if the hostname can be resolved by referencing the local hosts file, whose location varies by operating system. This file is a simple text file that maps hostnames to IP addresses and can provide a quick resolution without querying DNS.</li>
             </ul>
             </li>
             <li><p>DNS Server Request:</p>
             <ul>
             <li>If the hostname is not cached and cannot be found in the hosts file, the browser then sends a request to the DNS server configured in the network stack. This server is typically the local router or the ISP&#39;s caching DNS server, which stores previously resolved names to speed up future requests.</li>
             </ul>
             </li>
             <li><p>ARP Process for DNS Server:</p>
             <ul>
             <li>If the DNS server is on the same subnet, the network library follows the ARP (Address Resolution Protocol) process to resolve the IP address of the DNS server, ensuring that the request is directed correctly within the local network.</li>
             <li>If the DNS server is on a different subnet, the network library instead follows the ARP process for the default gateway IP, which acts as an intermediary to route the request to the appropriate subnet.</li>
             </ul>
             </li>
             </ol>
             <p>This systematic approach ensures that the browser efficiently resolves domain names to IP addresses, enabling it to establish a connection to the desired website. By checking the cache first, using the local hosts file, and finally querying the DNS server, the browser minimizes the time spent on hostname resolution.</p>
             <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2n1ngxq6v2d3g9tnw8bf.png" alt="Sequence of DNS Lookup"></p>
             <p>Sequence Diagram</p>
             <h3 id="arp-process">ARP Process</h3>
             <p>In order to send an ARP (Address Resolution Protocol) broadcast, the network stack library needs two key pieces of information: the target IP address that needs to be looked up and the MAC address of the interface that will be used to send out the ARP broadcast.</p>
             <h4 id="checking-the-arp-cache-">Checking the ARP Cache:</h4>
             <p>The ARP cache is first checked for an entry corresponding to the target IP address. If an entry exists, the library function returns the result in the format:
             <strong>Target IP = MAC</strong>.</p>
             <p>If the Entry is Not in the ARP Cache:</p>
             <p>If there is no entry for the target IP address, the following steps are taken:</p>
             <ul>
             <li>The route table is consulted to determine whether the target IP address is on any of the subnets listed in the local route table.<ul>
             <li>If it is found, the library uses the interface associated with that subnet.</li>
             <li>If not, the library defaults to using the interface that connects to the default gateway.</li>
             </ul>
             </li>
             <li>The MAC address of the selected network interface is then retrieved.<h4 id="sending-the-arp-request-">Sending the ARP Request:</h4>
             </li>
             </ul>
             <p>The network library constructs and sends a Layer 2 (data link layer of the OSI model) ARP request with the following format: ARP Request:</p>
             <ul>
             <li><strong>Sender MAC</strong>: interface:mac:address:here</li>
             <li><strong>Sender IP</strong>: interface.ip.goes.here</li>
             <li><strong>Target MAC</strong>: FF:FF:FF:FF:FF:FF (Broadcast)</li>
             <li><strong>Target IP</strong>: target.ip.goes.here </li>
             </ul>
             <p>Depending on the hardware setup between the computer and the router, the behavior of the ARP request varies:</p>
             <h5 id="directly-connected-">Directly Connected:</h5>
             <p>If the computer is directly connected to the router, the router will respond with an ARP Reply (see below).</p>
             <h5 id="hub-">Hub:</h5>
             <p>If the computer is connected to a hub, the hub will broadcast the ARP request out of all its other ports. If the router is connected to the same &quot;wire,&quot; it will respond with an ARP Reply (see below).</p>
             <h5 id="switch-">Switch:</h5>
             <p>If the computer is connected to a switch, the switch will check its local CAM/MAC table to identify which port has the MAC address being queried. If the switch has no entry for the MAC address, it will rebroadcast the ARP request to all other ports. If the switch does have an entry in its MAC/CAM table, it will send the ARP request only to the port that has the corresponding MAC address.</p>
             <ul>
             <li>If the router is on the same &quot;wire,&quot; it will respond with an ARP Reply (see below).</li>
             </ul>
             <h4 id="arp-reply-">ARP Reply:</h4>
             <p>The ARP reply will have the following format:</p>
             <p><strong>Sender MAC</strong>: target:mac:address:here</p>
             <p><strong>Sender IP</strong>: target.ip.goes.here</p>
             <p><strong>Target MAC</strong>: interface:mac:address:here</p>
             <p><strong>Target IP</strong>: interface.ip.goes.here</p>
             <p>Now that the network library has obtained the IP address of either the DNS server or the default gateway, it can resume its DNS process:</p>
             <ol>
             <li>The DNS client establishes a socket connection to UDP port 53 on the DNS server, utilizing a source port above 1023.</li>
             <li>If the response size exceeds the UDP limit, TCP will be used instead to accommodate the larger response.</li>
             <li>If the local or ISP DNS server does not have the requested information, it will initiate a recursive search, querying a hierarchy of DNS servers until the SOA (Start of Authority) is reached, at which point the answer is returned.</li>
             </ol>
             <h3 id="opening-of-a-socket">Opening of a Socket</h3>
             <p>Once the browser receives the IP address of the destination server, it combines this with the port number specified in the URL (where HTTP defaults to port 80 and HTTPS to port 443). The browser then makes a call to the system library function named <code>socket</code>, requesting a TCP socket stream using <code>AF_INET</code> or <code>AF_INET6</code> and <code>SOCK_STREAM</code>.</p>
             <h4 id="transport-layer-processing-">Transport Layer Processing:</h4>
             <ul>
             <li>This request is first processed by the Transport Layer, where a TCP segment is crafted. The destination port is added to the header, and a source port is chosen from within the kernel‚Äôs dynamic port range (as specified by <code>ip_local_port_range</code> in Linux).</li>
             </ul>
             <h4 id="network-layer-processing-">Network Layer Processing:</h4>
             <ul>
             <li>This segment is then sent to the Network Layer, which wraps it in an additional IP header. The IP addresses of both the destination server and the current machine are inserted to form a packet.</li>
             </ul>
             <h4 id="link-layer-processing-">Link Layer Processing:</h4>
             <ul>
             <li>The packet next arrives at the Link Layer, where a frame header is added. This header includes the MAC address of the machine‚Äôs NIC (Network Interface Card) as well as the MAC address of the gateway (local router). If the kernel does not know the MAC address of the gateway, it must broadcast an ARP query to find it.</li>
             </ul>
             <p>At this point, the packet is ready to be transmitted through one of the following methods:</p>
             <ul>
             <li><strong>Ethernet</strong></li>
             <li><strong>WiFi</strong></li>
             <li><strong>Cellular Data Network</strong></li>
             </ul>
             <p>For most home or small business Internet connections, the packet will pass from your computer, possibly through a local network, and then through a modem (Modulator/Demodulator). This modem converts digital 1‚Äôs and 0‚Äôs into an analog signal suitable for transmission over telephone, cable, or wireless telephony connections. On the other end of the connection, another modem converts the analog signal back into digital data for processing by the next <strong>network node</strong>, where the from and to addresses would be analyzed further.</p>
             <p>In contrast, larger businesses and some newer residential connections will use fiber or direct Ethernet connections, allowing the data to remain digital and be passed directly to the next network node for processing.</p>
             <p>Eventually, the packet will reach the router managing the local subnet. From there, it will continue to travel to the autonomous system‚Äôs (AS) border routers, traverse other ASes, and finally arrive at the destination server. Each router along the way extracts the destination address from the IP header and routes it to the appropriate next hop. The time to live (TTL) field in the IP header is decremented by one for each router that processes it. The packet will be dropped if the TTL field reaches zero or if the current router has no space in its queue (which may occur due to network congestion).
             This send and receive process happens multiple times following the TCP connection flow:</p>
             <ol>
             <li>The <strong>client</strong> chooses an Initial Sequence Number (ISN) and sends a packet to the server with the SYN bit set to indicate it is setting the ISN.</li>
             <li>The <strong>server</strong> receives the SYN and, if it is agreeable, performs the following:<ul>
             <li>Chooses its own initial sequence number.</li>
             <li>Sets the SYN bit to indicate it is choosing its ISN.</li>
             </ul>
             </li>
             <li><p>Copies the (client ISN + 1) to its ACK field and adds the ACK flag to indicate it is acknowledging receipt of the first packet.</p>
             </li>
             <li><p>The client acknowledges the connection by sending a packet that:</p>
             <ul>
             <li>Increases its own sequence number.</li>
             <li>Increases the receiver acknowledgment number.</li>
             <li>Sets the ACK field.</li>
             </ul>
             </li>
             <li><p><strong>Data Transfer</strong>: Data is transferred as follows:</p>
             <ul>
             <li>As one side sends N data bytes, it increases its sequence number (SEQ) by that number.</li>
             <li>When the other side acknowledges receipt of that packet (or a string of packets), it sends an ACK packet with the acknowledgment (ACK) value equal to the last received sequence from the other side.</li>
             </ul>
             </li>
             <li><p><strong>Closing the Connection</strong>: To close the connection:</p>
             <ul>
             <li>The side initiating the closure sends a FIN packet.</li>
             <li>The other side acknowledges the FIN packet and sends its own FIN.</li>
             <li>The initiating side acknowledges the other side‚Äôs FIN with an ACK.</li>
             </ul>
             </li>
             </ol>
             <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/w6jszxrn8742at79w9w1.png" alt="Sequence Diagram of Opening of a Socket"></p>
             <p>Opening of a Socket: Sequence Diagram</p>
             <h3 id="tls-handshake">TLS Handshake</h3>
             <ul>
             <li>The client computer sends a <code>ClientHello</code> message to the server, which includes its Transport Layer Security (TLS) version, a list of available cipher algorithms, and compression methods.</li>
             <li>In response, the server replies with a <code>ServerHello</code> message that specifies the TLS version, the selected cipher, the selected compression methods, and the server&#39;s public certificate signed by a Certificate Authority (CA). This certificate contains a public key that will be used by the client to encrypt the remainder of the handshake until a symmetric key can be agreed upon.</li>
             <li>The client verifies the server&#39;s digital certificate against its list of trusted CAs. If trust can be established based on the CA, the client generates a string of pseudo-random bytes and encrypts this string using the server&#39;s public key. These random bytes will be used to determine the symmetric key.</li>
             <li>The server decrypts the random bytes using its private key and utilizes these bytes to generate its own copy of the symmetric master key.</li>
             <li>The client sends a <code>Finished</code> message to the server, encrypting a hash of the transmission that has occurred up to this point with the symmetric key.</li>
             <li>The server generates its own hash and then decrypts the hash sent by the client to verify that it matches. If the hashes match, the server sends its own <code>Finished</code> message back to the client, which is also encrypted with the symmetric key.</li>
             <li>From this point forward, the TLS session transmits application (HTTP) data encrypted with the agreed-upon symmetric key.</li>
             </ul>
             <p>This handshake process establishes a secure connection between the client and server, ensuring that data transmitted over the connection is protected from eavesdropping and tampering.</p>
             <h3 id="if-a-packet-is-dropped">If a Packet is Dropped</h3>
             <p>Sometimes, due to network congestion or flaky hardware connections, TLS packets may be dropped before reaching their final destination. In such cases, the sender must decide how to react. The algorithm governing this response is known as <strong>TCP congestion control</strong>. The specific implementation can vary depending on the sender, with the most common algorithms being <strong>Cubic</strong> on newer operating systems and New Reno on many others.</p>
             <ul>
             <li>The client chooses a congestion window based on the <strong>maximum segment size</strong> (MSS) of the connection.</li>
             <li>For each packet acknowledged, the congestion window doubles in size until it reaches the &#39;slow-start threshold.&#39; In some implementations, this threshold is adaptive and can change based on network conditions.</li>
             <li>Once the slow-start threshold is reached, the window increases additively for each packet acknowledged. If a packet is dropped, the window reduces exponentially until another packet is acknowledged.</li>
             </ul>
             <p>This congestion control mechanism helps optimize network performance and stability, ensuring that data can be transmitted efficiently while minimizing the impact of packet loss.</p>
             <h3 id="http-protocol">HTTP Protocol</h3>
             <p>If the web browser used was developed by Google, instead of sending a standard HTTP request to retrieve a page, it may attempt to negotiate an &quot;upgrade&quot; from HTTP to the SPDY protocol with the server.</p>
             <p>If the client is using the HTTP protocol and does not support SPDY, it sends a request to the server in the following format:</p>
             <pre><code>GET <span class="hljs-regexp">/ HTTP/</span><span class="hljs-number">1.1</span>
             <span class="hljs-string">Host:</span> google.com
             <span class="hljs-string">Connection:</span> close
             [other headers]
             </code></pre><p>Here, <code>[other headers]</code> refers to a series of colon-separated key-value pairs formatted according to the HTTP specification and separated by single newlines. This assumes that the web browser is free of bugs that violate the HTTP specification and that it is using <strong>HTTP/1.1</strong>. If it were using a different version, such as <strong>HTTP/1.0</strong> or <strong>HTTP/0.9</strong>, it might not include the <code>Host</code> header in the request.</p>
             <p>HTTP/1.1 defines the &quot;close&quot; connection option for the sender to signal that the connection will be closed after the response is completed. For example:</p>
             <pre><code>Connection: <span class="hljs-built_in">close</span>
             </code></pre><p>HTTP/1.1 applications that do not support persistent connections <strong>MUST</strong> include the &quot;close&quot; connection option in every message.</p>
             <p>After sending the request and headers, the web browser sends a single blank newline to the server to indicate that the content of the request is complete.</p>
             <p>The server then responds with a response code that denotes the status of the request, structured as follows:</p>
             <pre><code><span class="hljs-number">200</span> OK
             <span class="hljs-string">[response headers]</span>
             </code></pre><p>This is followed by a single newline and then the payload containing the HTML content of <code>www.google.com</code>. The server may either close the connection or, if requested by the headers sent by the client, keep the connection open for reuse in further requests.</p>
             <p>If the HTTP headers sent by the web browser contained sufficient information for the web server to determine whether the version of the file cached by the web browser has been unmodified since the last retrieval (for example, if the web browser included an <code>ETag</code>header), the server may instead respond with:</p>
             <pre><code><span class="hljs-number">304</span> <span class="hljs-keyword">Not</span> Modified
             [<span class="hljs-built_in">response</span> headers]
             </code></pre><p>This response will have no payload, and the web browser will retrieve the HTML from its cache.</p>
             <p>After parsing the HTML, the web browser (and server) repeats this process for every resource (image, CSS, favicon.ico, etc.) referenced in the HTML page. In these cases, instead of <code>GET / HTTP/1.1</code>, the request will be structured as:</p>
             <pre><code><span class="hljs-keyword">GET</span> <span class="hljs-string">/$(URL</span> relative <span class="hljs-string">to</span> www.google.com) <span class="hljs-string">HTTP/1.1</span>
             </code></pre><p>If the HTML references a resource on a different domain than <code>www.google.com</code>, the web browser returns to the steps involved in resolving the other domain, following all steps up to this point for that domain. The <code>Host</code> header in the request will be set to the appropriate server name instead of <code>google.com</code>.</p>
             <h3 id="http-server-request-handling">HTTP Server Request Handling</h3>
             <p>The <strong>HTTPD (HTTP Daemon) server</strong> is responsible for handling requests and responses on the server side. The most common HTTPD servers include Apache and Nginx for Linux, as well as IIS for Windows.</p>
             <ol>
             <li><strong>Receiving the Request:</strong> The HTTPD server receives the incoming request from the client.</li>
             <li><strong>Breaking Down the Request:</strong> The server analyzes the request and extracts the following parameters:<ul>
             <li><strong>HTTP Request Method:</strong> This could be one of several methods, including <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, or <code>TRACE</code>. In the case of a URL entered directly into the address bar, the method will typically be <code>GET</code>.</li>
             <li><strong>Domain:</strong> In this case, the domain is <code>google.com</code>.</li>
             <li><strong>Requested Path/Page:</strong> Here, the requested path is <code>/</code>, indicating that no specific page was requested; thus, <code>/</code> is treated as the default path.</li>
             </ul>
             </li>
             <li><strong>Verifying the Virtual Host:</strong> The server checks whether a Virtual Host is configured for <code>google.com</code>. </li>
             <li><strong>Method Verification:</strong> The server verifies that <code>google.com</code> can accept <code>GET</code> requests.</li>
             <li><strong>Client Permission Check:</strong> The server checks if the client is allowed to use this method based on criteria such as IP address, authentication, etc. </li>
             <li><strong>Request Rewriting:</strong> If the server has a rewrite module installed (such as <code>mod_rewrite</code> for Apache or URL Rewrite for IIS), it attempts to match the request against any configured rules. If a matching rule is found, the server rewrites the request according to that rule. </li>
             <li><strong>Content Retrieval:</strong> The server retrieves the content that corresponds to the request. In this case, it will typically default to the index file since the request path is <code>/</code>. While there are cases that can override this behavior, using the index file is the most common method.</li>
             <li><strong>File Parsing and Processing:</strong> The server parses the index file according to the designated handler. If Google is using PHP, for example, the server will utilize PHP to interpret the index file and stream the output back to the client.</li>
             </ol>
             <p>By following these steps, the HTTPD server efficiently processes incoming requests and returns the appropriate responses to the client.</p>
             <h3 id="browser">Browser</h3>
             <p>The primary functionality of a browser is to present the web resources you choose by requesting them from a server and displaying them in the browser window. The resource is typically an HTML document but may also include PDFs, images, or other types of content. The location of the resource is specified by the user using a URI (Uniform Resource Identifier).</p>
             <p>The way a browser interprets and displays HTML files is defined by the HTML and CSS specifications, which are maintained by the W3C (World Wide Web Consortium), the standards organization for the web.</p>
             <p>Browser user interfaces share many common features, including:</p>
             <ul>
             <li>An address bar for entering a URI</li>
             <li>Back and forward buttons for navigation</li>
             <li>Bookmarking options for saving favorite pages</li>
             <li>Refresh and stop buttons for refreshing or halting the loading of current documents</li>
             <li>A home button that takes you to your home page</li>
             </ul>
             <h4 id="browser-high-level-structure">Browser High-Level Structure</h4>
             <p>The components of a browser can be broken down as follows:</p>
             <ul>
             <li><strong>User Interface:</strong> This includes the address bar, back/forward buttons, bookmarking menu, and any other part of the browser&#39;s display except for the window where the requested page is shown.</li>
             <li><strong>Browser Engine:</strong> The browser engine acts as a bridge between the user interface and the rendering engine, managing actions and interactions.</li>
             <li><strong>Rendering Engine:</strong> Responsible for displaying requested content, the rendering engine parses HTML and CSS, transforming the parsed content into a visual representation on the screen.</li>
             <li><strong>Networking:</strong> This component handles network calls, such as HTTP requests, and utilizes different implementations tailored for various platforms while providing a platform-independent interface.</li>
             <li><strong>UI Backend:</strong> The UI backend is responsible for drawing basic widgets like combo boxes and windows. It exposes a generic interface that is not specific to any platform and relies on the operating system&#39;s user interface methods.</li>
             <li><strong>JavaScript Engine:</strong> This engine parses and executes JavaScript code, allowing for dynamic content and interactivity within web pages.</li>
             <li><strong>Data Storage:</strong> This acts as a persistence layer, enabling the browser to save various types of data locally, such as cookies. Browsers also support storage mechanisms like localStorage, IndexedDB, WebSQL, and FileSystem.</li>
             </ul>
             <p>Each of these components works together to create a seamless browsing experience, allowing users to access and interact with web resources efficiently.</p>
             <h3 id="html-parsing">HTML Parsing</h3>
             <p>The rendering engine begins retrieving the contents of the requested document from the networking layer, typically in 8 kB chunks. The primary responsibility of the HTML parser is to transform the HTML markup into a structured representation known as a parse tree.</p>
             <p>The output tree, referred to as the &quot;parse tree,&quot; consists of a hierarchy of DOM (Document Object Model) element and attribute nodes. The DOM serves as the object representation of the HTML document, providing an interface for HTML elements to interact with external scripts, such as JavaScript. The root of this tree is the &quot;Document&quot; object, and prior to any scripting manipulations, the DOM maintains an almost one-to-one correspondence with the original markup.</p>
             <h4 id="the-parsing-algorithm">The Parsing Algorithm</h4>
             <p>HTML cannot be parsed effectively using traditional top-down or bottom-up parsers due to several factors:</p>
             <ul>
             <li><strong>Forgiving Nature of the Language:</strong> HTML is designed to be lenient with syntax errors, allowing browsers to display content even when the markup is not perfectly structured.</li>
             <li><strong>Browser Error Tolerance:</strong> Browsers are built to handle common cases of invalid HTML, ensuring that users have a functional experience.</li>
             <li><strong>Reentrancy of the Parsing Process:</strong> In other programming languages, the source remains unchanged during parsing. However, in HTML, dynamic elements (like <code>&lt;script&gt;</code> tags containing <code>document.write()</code> calls) can modify the input during parsing, which necessitates a different approach.
             Because of these challenges, browsers employ a custom parser tailored for HTML. The parsing algorithm is thoroughly described in the HTML5 specification and consists of two primary stages: tokenization and tree construction.</li>
             </ul>
             <h4 id="actions-when-parsing-is-finished">Actions When Parsing is Finished</h4>
             <p>Once the parsing is complete, the browser proceeds to fetch external resources linked to the page, such as CSS stylesheets, images, and JavaScript files. At this point, the browser marks the document as interactive and begins parsing scripts that are in &quot;deferred&quot; mode, meaning those scripts are intended to execute after the document has been fully parsed. The document state is then set to &quot;complete,&quot; and a &quot;load&quot; event is triggered.</p>
             <p>Importantly, browsers do not generate an &quot;Invalid Syntax&quot; error for HTML pages. Instead, they automatically correct any invalid content and continue processing the document, ensuring that users can view web pages with minimal disruption.</p>
             <h2 id="css-interpretation">CSS Interpretation</h2>
             <p>The process of CSS interpretation involves several key steps:</p>
             <ul>
             <li><strong>Parsing CSS Files: </strong>The browser parses external CSS files, the contents within <code>&lt;style&gt;</code> tags, and the values within <code>style</code> attributes. This parsing follows the &quot;CSS lexical and syntax grammar,&quot; which defines the rules and structure of valid CSS.</li>
             <li><strong>Creating StyleSheet Objects:</strong> Each parsed CSS file is transformed into a <code>StyleSheet</code> object. Each <code>StyleSheet</code> object encapsulates the CSS rules, including selectors and the corresponding CSS declarations. This structured representation allows for efficient access and manipulation of styles.</li>
             <li><strong>Parsing Techniques:</strong> The CSS parser can utilize either top-down or bottom-up parsing techniques, depending on the specific parser generator employed. These techniques determine how the parser reads and processes the CSS rules, affecting the efficiency and accuracy of the parsing process.
             <img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ev3uwi9zq3cnsbgtq9cu.png" alt="CSS Interpretation"></li>
             </ul>
             <p>Through this interpretation, the browser builds a comprehensive understanding of how to apply styles to the HTML elements in the DOM, facilitating the rendering of the web page with the intended visual presentation.</p>
             <h3 id="page-rendering">Page Rendering</h3>
             <p>The rendering process of a web page involves several structured steps:</p>
             <ul>
             <li><strong>Creating the Frame Tree:</strong> The rendering engine constructs a &#39;Frame Tree&#39; or &#39;Render Tree&#39; by traversing the DOM nodes and calculating the computed CSS styles for each node. This tree represents the visual structure of the page.</li>
             <li><strong>Calculating Preferred Width:</strong> The preferred width for each node in the Frame Tree is calculated in a bottom-up manner. This involves summing the preferred widths of the child nodes along with the node&#39;s horizontal margins, borders, and padding.</li>
             <li><strong>Calculating Actual Width:</strong> The actual width of each node is determined in a top-down approach by distributing the available width among its children based on their needs.</li>
             <li><strong>Calculating Height:</strong> The height of each node is calculated bottom-up by applying text wrapping and summing the heights of the child nodes along with the node&#39;s margins, borders, and padding.</li>
             <li><strong>Determining Node Coordinates:</strong> The coordinates of each node are computed using the width and height information gathered in the previous steps.</li>
             <li><strong>Handling Complex Elements:</strong> More intricate calculations are performed for elements that are floated, positioned absolutely or relatively, or that employ other complex features. For further details, refer to the CSS specifications at <a href="http://dev.w3.org/csswg/css2/">CSS2</a> and the <a href="http://www.w3.org/Style/CSS/current-work">current CSS work</a>.</li>
             <li><strong>Creating Layers:</strong> Layers are created to describe which parts of the page can be animated together without requiring re-rasterization. Each frame/render object is assigned to a specific layer.</li>
             <li><strong>Allocating Textures:</strong> Textures are allocated for each layer of the page to optimize rendering performance.</li>
             <li><strong>Executing Drawing Commands:</strong> The frame/render objects for each layer are traversed, and drawing commands are executed for their respective layers. This rendering can be handled by the CPU or directly drawn on the GPU using technologies like D2D (Direct2D) or SkiaGL.</li>
             <li><strong>Reusing Calculated Values: </strong> The rendering process can leverage calculated values from the previous rendering of the webpage, enabling more efficient incremental changes that require less computational work.</li>
             <li><strong>Compositing Layers:</strong> The final page layers are sent to the compositing process, where they are combined with other visible content, such as the browser chrome, iframes, and addon panels.</li>
             <li><strong>Finalizing Render Commands:</strong> The final layer positions are computed, and composite commands are issued via graphics APIs like Direct3D or OpenGL. The GPU command buffers are flushed to the GPU for asynchronous rendering, and the completed frame is sent to the window server for display.
             <img src="https://dev-to-uploads.s3.amazonaws  .com/uploads/articles/qiuzkx1dgop3uhf0xrov.png" alt="How to render a webpage?"></li>
             </ul>
             <h3 id="gpu-rendering">GPU Rendering</h3>
             <ul>
             <li>During the rendering process, graphical computing tasks can utilize either the general-purpose CPU or the specialized graphical processor GPU.</li>
             <li>When leveraging the GPU for graphical rendering computations, the graphical software layers divide the workload into multiple smaller tasks. This approach allows them to take full advantage of the GPU&#39;s massive parallelism, which is particularly effective for the floating-point calculations required in the rendering process.</li>
             <li>The GPU excels in handling numerous operations simultaneously, making it well-suited for rendering complex visual content efficiently and rapidly. This parallel processing capability significantly enhances performance, especially in applications involving high-resolution graphics, animations, and real-time rendering.</li>
             <li>As a result, using the GPU not only speeds up the rendering process but also enables more sophisticated visual effects and smoother user experiences in modern web applications and graphics-intensive software.</li>
             </ul>
             <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xin9xylsdriy0dp86jyi.png" alt="Benefits of GPU Rendering"></p>
             <p>This image is also rendered by the GPU</p>
             <h3 id="post-rendering-and-user-induced-execution">Post-Rendering and User-Induced Execution</h3>
             <p>After the rendering process is complete, the browser executes JavaScript code triggered by various events, such as timing mechanisms (like a Google Doodle animation) or user interactions (e.g., typing a query into the search box and receiving suggestions).</p>
             <ul>
             <li><strong>Plugins:</strong> Additionally, plugins such as Flash or Java may also execute, although they typically do not run at this point on the Google homepage.</li>
             <li><strong>Network Requests:</strong> JavaScript scripts can initiate further network requests, fetching additional resources or data as needed.</li>
             <li><strong>DOM Modifications:</strong> These scripts have the ability to modify the existing page or its layout, which can lead to another round of page rendering and painting. This dynamic capability allows for interactive experiences, where content can change in real-time based on user actions or other conditions, enhancing the overall functionality and responsiveness of the web application.
             The interaction between JavaScript execution and the rendering engine is crucial for creating rich, engaging web experiences, allowing developers to build applications that respond intuitively to user input and changing contexts.</li>
             </ul>
             <h2 id="introduction-to-bits-signals-and-packets">Introduction to Bits, Signals, and Packets</h2>
<p>The ability to deliver and exchange information over the world&#39;s communication networks has revolutionized how people work, play, and live. At the turn of the century, the U.S. National Academy of Engineering listed 20 technologies with the most significant societal impact in the 20th century. This list included life-changing innovations like electrification, the automobile, and the airplane. It also included four communication technologies‚Äîradio and television, the telephone, the Internet, and computers‚Äîwhose technological underpinnings are the focus of this book.</p>
<p>Surprisingly, the Internet ranked only #13, as it was developed late in the century, and the committee believed its most significant impacts would occur in the 21st century. That prediction seems accurate: the spread of wireless networks and mobile devices, the rise of social networks, and anytime, anywhere communication have changed commerce, social connections, and even driven societal and political changes.</p>
<p>Communication is fundamental to modern life. It&#39;s hard to imagine life without the Internet, its applications, or networked mobile devices. By early 2011, over 5 billion mobile phones were active worldwide, over a billion with &quot;broadband&quot; connectivity ‚Äì exceeding the number of people with electricity, shoes, toothbrushes, or toilets in 2011!</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ufp3kc2aq6ko8ob2ew3z.png" alt="Internet&#39;s Impact on Communication and Society"></p>
<h3 id="objectives">Objectives</h3>
<p>This post/lesson(whatever you call it) aims to explain how communication networks work. This is worth studying for two reasons:  </p>
<ul>
<li>to understand the design principles and analysis techniques used in these systems; </li>
<li>because the technical ideas are relevant to other fields in computer science (CS) and electrical engineering (EE). This makes studying communication systems a great way to learn broadly applicable concepts.</li>
</ul>
<p>At MIT(Massachusetts Institute of Technology), sophomores take such a course, with some exposure to probability and Fourier series.</p>
<p>Traditionally, &quot;low-level communication&quot; (how information moves across a single link) has been considered an EE topic, while &quot;networking&quot; (building networks of multiple links) has been a CS topic. Traditional digital communication courses rarely address network building, and computer network courses treat communication over physical links as a black box. This book aims to bridge this gap, providing a comprehensive understanding of both aspects.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wien2kt3vrwknvd7b6as.png" alt="Understanding Communication Networks"></p>
<p>We&#39;ll cover communication systems end-to-end: from the source with information to transmit, to packets (messages broken down for transmission), to bits (&quot;0&quot; or &quot;1&quot;), to signals (analog waveforms sent over links like wires, fiber, radio, or acoustic waves). We&#39;ll examine diverse networks: simple point-to-point links, shared media with multiple nodes, and larger multi-hop networks connected to form even bigger networks.</p>
<h3 id="themes">Themes</h3>
<p>Three challenges are central to digital communication: reliability, sharing, and scalability. This introductory section focuses on the first two.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3m4vzm1t6twy62k4bd8h.png" alt="Digital Communication"></p>
<h4 id="reliability">Reliability</h4>
<p>Many factors make communication unreliable. We&#39;ll study techniques to improve reliability, all of which employ redundancy to achieve reliability with unreliable components, relying on independent component failures.</p>
<p>The main challenge is overcoming noise, interference, bit errors, packet losses (from uncorrectable errors, queue overflows, or link/software failures), all of which degrade communication quality.</p>
<p>Besides reliability, speed is also important. Reliability techniques often use redundancy, reducing speed. Many communication systems balance reliability and speed.</p>
<p>Communication speeds have increased dramatically, from kilobits per second in the early 1980s to 100+ Megabits per second wirelessly and 1-10 Gigabits per second over wired links today.</p>
<p>We&#39;ll explore why communication is unreliable and how to address it, using error-correcting codes, handling inter-symbol interference, retransmission protocols, and fault-tolerant routing.</p>
<h4 id="efficient-sharing">Efficient Sharing</h4>
<p>Dedicated links for every node pair are prohibitively expensive. Sharing is essential. We&#39;ll study sharing point-to-point links, shared media, and multi-hop networks.</p>
<p>We&#39;ll cover sharing a medium (relevant to Ethernet, WiFi, cellular networks, and satellite networks), modulation/demodulation (transmitting over different frequencies), and medium access control (MAC) protocols (rules governing network node behavior). We&#39;ll explore time sharing (each node transmits for a dedicated time) and frequency sharing (dividing bandwidth). Then we&#39;ll move on to multi-hop networks, where many communications share links, orchestrated by switches.</p>
<p>Key questions include how multiple communications share the network, how messages traverse the network, and how to ensure reliable communication across a multi-hop network.</p>
<p>Sharing techniques and reliability mechanisms determine network efficiency. Efficiency can be framed as minimizing cost for given requirements or maximizing &quot;useful work&quot; (aggregate throughput, throughput variation, and average delay/latency) for a given network. This post focuses on throughput and latency.</p>
<h4 id="scalability">Scalability</h4>
<p>Scalability (designing networks that handle large sizes) is important. This post touches upon it briefly, leaving detailed discussion for later lessons.</p>
<h3 id="outline-and-plan">Outline and Plan</h3>
<p>The lesson is divided into four parts: the source, and the abstractions of bits, signals, and packets, studied in that order.</p>
<ol>
<li><strong>The source</strong>: We begin with the basics of information, entropy, source coding (data compression), Huffman codes, and the Lempel-Ziv-Welch algorithm.</li>
<li><strong>Bits</strong>: We address overcoming bit errors with error-correcting codes: linear block codes and convolutional codes.</li>
<li><strong>Signals</strong>: We cover modulation/demodulation, modeling signal distortions with linear time-invariant (LTI) channels, time/frequency domain representations, and frequency response of channels/filters.</li>
<li><strong>Packets</strong>: We study medium sharing with MAC protocols, routing in multi-hop networks, and reliable data transport protocols.</li>
</ol>
<h2 id="information-entropy-and-the-motivation-for-source-codes">Information, Entropy, and the Motivation for Source Codes</h2>
<p>Claude Shannon&#39;s theory of information (developed in the late 1940s) is a groundbreaking idea that has transformed many technological fields, especially communication systems and networks. This chapter introduces the intuition behind information, defines it mathematically, and links it to entropy, a property of data sources.</p>
<p>These concepts enable efficient data compression before communication or storage, allowing for recovery of the original data without distortion.  A core idea is <em>source coding</em>, which maps each symbol from a data source to a <em>codeword</em> with desirable properties. A message is a sequence of symbols. Our focus is <em>lossless source coding</em>, where the original message can be perfectly recovered from an uncorrupted transmission.</p>
<h3 id="information-and-entropy">Information and Entropy</h3>
<p>Shannon, building on Hartley&#39;s work, realized that information can be defined generally, independent of the application or message semantics. Communication involves a sender (S) choosing and sending one of several possible messages to a receiver (R). For example, S could indicate the British arrival route:</p>
<ul>
<li>&quot;1&quot; if by land</li>
<li>&quot;2&quot; if by sea</li>
</ul>
<p>If each choice is equally likely (no prior knowledge), the information conveyed is 1 bit. This bit can encode the choice.  1000 such independent events can be encoded with 1000 bits.</p>
<p>If prior knowledge suggests a higher probability for one choice (e.g., land due to a storm), then the less likely message (sea) conveys more information.  Similarly, a temperature of 75¬∞F in Boston in January is more informative than 32¬∞F.</p>
<p>Information about an event depends on its probability (p). Lower probability (less likely event) implies higher information.</p>
<h4 id="definition-of-information">Definition of information</h4>
<p>Hartley defined information (I) as:</p>
<p>I = log(1/p) = -log(p)  (2.1)</p>
<p>The base-2 logarithm is used, and the unit of information is a bit.  The logarithmic function ensures <em>additivity</em>:  information from two independent events A and B (probabilities pA and pB) adds up:</p>
<p>IA + IB = log(1/pA) + log(1/pB) = log(1/(pA*pB)) = log(1/P(A and B))</p>
<h4 id="examples">Examples</h4>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/9nlcr4i5bredp3sg8kbp.png" alt="Information Content of Decimal Digit Events"></p>
<h4 id="entropy">Entropy</h4>
<p>Entropy (H) quantifies the expected information from a set of mutually exclusive events. If event <em>i</em> has probability pi:</p>
<p>H(p1, p2, ... pN) = Œ£ pi * log(1/pi)   (2.2)</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/qwbj2rxixp5deixm63bb.png" alt="Solving Process of the Equation above"></p>
<p>Entropy is measured in bits and represents the average uncertainty. For two mutually exclusive events with probabilities p and 1-p:</p>
<p>H(p, 1-p) = -p<em>log(p) - (1-p)</em>log(1-p)   (2.3)</p>
<p>H(p) is symmetric around p = 1/2, with a maximum of 1 bit at p = 1/2. H(0) = H(1) = 0.  Entropy is always non-negative and H(p1, p2, ... pN) ‚â§ log N.</p>
<h3 id="source-codes">Source Codes</h3>
<p><em>Source coding</em> efficiently encodes messages.  Many messages have standard encodings (ASCII, image pixels, audio samples). These are fixed-length encodings, easily manipulated.</p>
<p>However, these encodings can be inefficient.  In English text, &#39;e&#39; occurs more frequently than &#39;x&#39;. Encoding &#39;e&#39; with fewer bits and &#39;x&#39; with more bits can shorten the average message length.  This aligns with the information concept: frequent symbols (higher pi) convey less information and need fewer bits.</p>
<p>A <em>code</em> maps information to bit sequences. A <em>codeword</em> is a bit sequence in the code. <em>Source codes</em> aim to compress data by matching encoded message length to the information content (entropy).</p>
<p>Example: encoding 1000 grades (A, B, C, D) with probabilities:</p>
<p>Fixed-length encoding: 2 bits/grade (total 2000 bits).  Decoding is simple, but inefficient.</p>
<p>Variable-length encoding (example): A=10, B=0, C=110, D=111.  Length depends on the message.  Decoding requires sequential processing.  This example code is not optimal.</p>
<h3 id="how-much-compression-is-possible-">How Much Compression Is Possible?</h3>
<p>Ideally, compression uses only the necessary bits to represent the information. Entropy (Equation 2.2) provides the lower bound on the average number of bits needed to avoid ambiguity. Sending fewer bits leads to unresolved choices at the receiver.</p>
<p>In the grades example, the expected information per grade is 1.626 bits.  Encoding 1000 grades requires 1626 bits on average. The example variable-length code uses 1667 bits, so it&#39;s not optimal.  Encoding sequences of grades can improve compression.</p>
<p>Finding good codes is challenging. Sometimes, context-specific codes can be very efficient (e.g., encoding Shakespeare sonnets using just 8 bits if both sender and receiver know all the sonnets).</p>
<h3 id="why-compression-">Why Compression?</h3>
<p>Compression offers several advantages:</p>
<ul>
<li><strong>Faster transmission:</strong> Shorter messages reduce transmission time and free up network capacity.</li>
<li><strong>Efficient resource use:</strong> Smaller messages conserve network resources (bandwidth, buffers), accommodating more communications.</li>
<li><strong>Improved throughput over error-prone links:</strong> Compression before error-correction coding allows for optimized redundancy for error resilience.</li>
</ul>
<p>Compression is typically an end-to-end function (application layer), but can also be applied at the link layer if the data is compressible and contains redundancy.  The next chapter covers Huffman Codes and Lempel-Ziv-Welch (LZW) compression.</p>
<h2 id="compression-algorithms-huffman-and-lempel-ziv-welch-lzw-">Compression Algorithms: Huffman and Lempel-Ziv-Welch (LZW)</h2>
<p>This chapter discusses two source coding algorithms for message compression (where a message is a sequence of symbols): Huffman coding and Lempel-Ziv-Welch (LZW). Huffman coding is efficient when symbol probabilities are known and independent. LZW is adaptive, requiring no prior knowledge of probabilities.  Both are widely used (GIF, JPEG, MPEG, MP3, etc.).</p>
<h3 id="properties-of-good-source-codes">Properties of Good Source Codes</h3>
<p>A <em>code</em> maps symbols from an alphabet (text, pixel intensities, or abstract symbols) to <em>codewords</em>.  Binary codewords are convenient for many communication channels.</p>
<p>Example: Encoding grades in 6.02: A=1, B=01, C=000, D=001. A sequence of grades could be transmitted as 0010001110100001, decoded as &quot;DCAAABCB&quot;.</p>
<p><strong>Instantaneous codes:</strong> A symbol is decoded as soon as its codeword is received.  The grade encoding above is instantaneous. Non-instantaneous codes require looking ahead or decoding from the end, making them harder to decode.</p>
<p><strong>Code trees and prefix-free codes:</strong> A <em>code tree</em> visualizes codes.  In a binary code tree, edges are labeled with 0 or 1. The path from the root to a symbol gives its encoding.  <em>Prefix-free codes</em> have symbols only at leaf nodes, ensuring no codeword is a prefix of another. Prefix-free codes are instantaneous.</p>
<p><strong>Expected code length (L):</strong> For <em>N</em> symbols with probabilities <em>pi</em> and codeword lengths <em>li</em>: L = Œ£ pi <em> li.  Codes with small L are desirable for compression. An </em>optimal code* has minimum L. Shannon showed that L ‚â• H (entropy), and codes achieving entropy asymptotically exist.</p>
<h3 id="huffman-codes">Huffman Codes</h3>
<p>Huffman codes provide efficient encoding given symbol probabilities.  More likely symbols get shorter codes.</p>
<p>Huffman&#39;s algorithm builds the code tree bottom-up, starting with the least probable symbols:</p>
<ol>
<li>Input: Set <em>S</em> of (probability, symbol) tuples.</li>
<li>Combine the two least probable symbols into a new tuple (combined symbol, sum of probabilities). Add the new tuple to <em>S</em>.</li>
<li>Repeat step 2 until <em>S</em> has only one tuple (the root).</li>
</ol>
<p>The resulting code tree defines the variable-length code.</p>
<h4 id="properties-of-huffman-codes">Properties of Huffman Codes</h4>
<ul>
<li><strong>Non-uniqueness:</strong> Multiple optimal codes (and trees) may exist due to arbitrary tie-breaking during tree construction.</li>
<li><strong>Optimality:</strong> Huffman codes have minimal expected length among instantaneous codes for independent symbols drawn from a fixed, known probability distribution.</li>
</ul>
<h3 id="lzw-an-adaptive-variable-length-source-code">LZW: An Adaptive Variable-length Source Code</h3>
<p>Simple Huffman coding based on letter probabilities has limitations.  Adaptive encoding, which adjusts to the message content, can perform better.  LZW is a popular adaptive algorithm.</p>
<p>LZW builds a string table mapping symbol sequences to/from <em>N</em>-bit indices. The table (2^N entries) is initialized with single-byte sequences (0-255).  Encoding:</p>
<ol>
<li>Accumulate bytes while the sequence (S) is in the table.</li>
<li>When S + next byte (b) is not in the table:<ul>
<li>Transmit the code for S.</li>
<li>Add S + b to the table.</li>
<li>Reset S to b.</li>
</ul>
</li>
<li>Repeat until all bytes are processed; then transmit the code for the final S.</li>
</ol>
<p>The decoder rebuilds the table as it receives codes, enabling it to recover the original message.</p>
<p>LZW observations:</p>
<ul>
<li><strong>Greedy:</strong> Finds longest matches.</li>
<li><strong>Adaptive:</strong>  Table entries reflect actual message sequences.</li>
<li><strong>Suboptimal:</strong>  May include unused entries.</li>
<li><strong>Variable compression:</strong>  Compression increases as the table fills.</li>
<li><strong>Table reinitialization:</strong>  The table is reset when full, adapting to changing probabilities.  Some variants use a CLEAR code for explicit resets.</li>
</ul>
<h2 id="why-digital-communication-abstractions-and-digital-signaling">Why Digital? Communication Abstractions and Digital Signaling</h2>
<p>This chapter explains analog and digital communication, focusing on the problems with analog and the rationale for digital. It presents methods for sending and receiving digital data over analog communication links (necessary because physical links are fundamentally analog at the lowest level). It also introduces a layered communication model: messages ‚Üí packets ‚Üí bits ‚Üí signals, which forms the basis for the rest of the book.</p>
<h3 id="sources-of-data">Sources of Data</h3>
<p>Communication technologies enable users (human or application) to exchange messages.  Data sources can be inherently digital (e.g., computer-generated data) or analog (e.g., video, audio, sensor data).  Modern systems often digitize all data, regardless of the source.</p>
<h3 id="why-digital-">Why Digital?</h3>
<p>Digital communication excels for two reasons:</p>
<ol>
<li><strong>Modularity:</strong>  The digital abstraction enables building large systems by composing modules.</li>
<li><strong>Sophisticated Processing:</strong> It allows using algorithms to enhance data quality and system performance.</li>
</ol>
<p>However, physical links are analog, requiring digital-to-analog and analog-to-digital conversions.</p>
<h4 id="why-analog-is-natural-in-many-applications">Why analog is natural in many applications</h4>
<p>Analog representations map well to physical link properties. Examples:</p>
<ul>
<li><p><strong>Black-and-white TV:</strong> Image luminance (shade of gray) is represented by voltage levels (0V = black, 1V = white).</p>
</li>
<li><p><strong>Analog telephone:</strong> Sound waves are converted to electrical signals.</p>
</li>
</ul>
<p>Analog signals can be sent at different voltage/intensity/wavelength levels, easily measured by the receiver.</p>
<h4 id="so-why-not-analog-">So why not analog?</h4>
<p>No communication link is error-free. Noise and distortions perturb signals, and these errors accumulate across multiple transmission stages (cascading effect). This makes analog systems difficult to build reliably, especially complex ones. Digital signaling addresses this problem.</p>
<h3 id="digital-signaling-mapping-bits-to-signals">Digital Signaling: Mapping Bits to Signals</h3>
<p>Digital signaling uses discrete values to represent bits, enabling robust distinction from noise. <em>Binary signaling</em> uses two voltages: V0 for &quot;0&quot; and V1 for &quot;1&quot;.  V0 and V1 must be sufficiently separated to handle noise.</p>
<p>The receiver uses a threshold voltage (Vth = (V0 + V1) / 2) to map received voltages to bits (voltage &lt; Vth ‚Üí &quot;0&quot;, voltage ‚â• Vth ‚Üí &quot;1&quot;).  Precisely measuring near Vth is difficult, but not crucial if V0 and V1 are far apart.</p>
<h4 id="signals-in-this-lesson">Signals in this lesson</h4>
<p>Transmission signals are fixed-voltage waveforms held for a specific time.  Continuous signals are represented by discrete-time samples. The <em>sample rate</em> (samples per second) is agreed upon by sender and receiver. <em>Sample interval</em> is the time between samples.</p>
<h4 id="clocking-transmissions">Clocking Transmissions</h4>
<p>Sender and receiver must agree on a clock rate. Bits are sent on clock transitions. <em>Samples_per_bit</em> is the number of samples per bit. The receiver infers clock edges from transitions in received samples.</p>
<p>Challenges:</p>
<ol>
<li><strong>Clock synchronization:</strong> Sender and receiver clocks may differ.  Solution: Adaptive timing at the receiver based on detected transitions.</li>
<li><strong>Ensuring frequent transitions:</strong> Needed for clock recovery. Solution: <em>Line coding</em> (e.g., 8b/10b).</li>
</ol>
<h3 id="clock-and-data-recovery">Clock and Data Recovery</h3>
<p>Receiver clock may be slightly faster or slower than the sender&#39;s.  The receiver dynamically adjusts its sampling index based on transitions:</p>
<ul>
<li>If the halfway sample between current and previous points is the <em>same</em> as the current sample (sampling too late): Increment the index by samples_per_bit - 1.</li>
<li>If the halfway sample is <em>different</em> (sampling too early): Increment by samples_per_bit + 1.</li>
<li>If no transition: Increment by samples_per_bit.</li>
</ul>
<p>Initial correction is aided by a training sequence of alternating 0s and 1s at the start of transmission.</p>
<h3 id="line-coding-with-8b-10b">Line Coding with 8b/10b</h3>
<p>8b/10b addresses DC balance and frequent transitions. It maps 8-bit symbols to 10-bit transmission symbols, ensuring:</p>
<ul>
<li>Maximum run of 0s or 1s is 5 bits.</li>
<li>Maximum difference between 1s and 0s count at any sample is 6.</li>
<li>Special 7-bit sequences enable packet boundary detection.</li>
</ul>
<p>Encoding process:</p>
<ol>
<li>Packet data is divided into bytes.</li>
<li>Each byte is mapped to a 10-bit symbol.</li>
<li>Packets are framed with a training sequence and a SYNC pattern for synchronization.</li>
</ol>
<h3 id="communication-abstractions">Communication Abstractions</h3>
<p>A communication system involves several modules: Mapper (bits to signals), Demapper (signals to bits), Channel coding (error correction), Channel decoding. Messages are broken into packets and transmitted over multiple links.  The three key abstractions are <em>packets</em>, <em>bits</em>, and <em>signals</em>.  The book focuses on these and their interactions within the communication network.</p>
<h2 id="coping-with-bit-errors-using-error-correction-codes">Coping with Bit Errors using Error Correction Codes</h2>
<p>This chapter discusses techniques for reliable digital communication, focusing on adding redundancy to combat inevitable bit errors in communication channels and storage media.  The core concept is <em>channel coding</em>: encoding at the sender and decoding at the receiver to correct errors or detect uncorrectable errors.  The chapter focuses on error <em>correction</em> codes, specifically linear block codes and (later) convolutional codes.</p>
<h3 id="bit-errors-and-bsc">Bit Errors and BSC</h3>
<p>The <em>Binary Symmetric Channel (BSC)</em> model characterizes bit errors with a single parameter, Œµ (bit-flip probability), where a transmitted bit flips with probability Œµ, independently of other bits. Œµ can be estimated empirically.  Packet error probability (PER) for a packet of size <em>S</em> bits:</p>
<p>PER = 1 - (1 - Œµ)^S   (5.1)</p>
<p>When Œµ &lt;&lt; 1: PER ‚âà SŒµ   (5.2)</p>
<p>Real-world channels may exhibit <em>burst errors</em> where error probability depends on history (higher if recent bits were also in error).</p>
<h3 id="the-simplest-code-repetition">The Simplest Code: Repetition</h3>
<p>A <em>repetition code</em> encodes bit <em>b</em> as <em>n</em> copies of <em>b</em>. The <em>code rate</em> is 1/<em>n</em>.  <em>Maximum likelihood decoding</em> selects the most likely message given the received codeword. For a BSC, this means choosing the codeword with the most bits in common with the received one.</p>
<p>Decoding error probability for repetition code (see Equation 5.3 in the original text). The probability decreases exponentially with the code rate but is inefficient due to high overhead.</p>
<h3 id="embeddings-and-hamming-distance">Embeddings and Hamming Distance</h3>
<p><em>Hamming distance (HD)</em> between two n-bit words is the number of differing bit positions. For single error correction (SEC), HD between any two valid codewords must be at least 3.  A code with minimum Hamming distance <em>D</em> can detect <em>D</em>-1 errors and correct floor(<em>D</em>/2 -1) errors.</p>
<h3 id="linear-block-codes-and-parity-calculations">Linear Block Codes and Parity Calculations</h3>
<p><em>Linear block codes</em> (n, k) map k-bit messages to n-bit codewords using linear functions (weighted sums) over message bits. <em>Algebraic block codes</em> perform such operations within the block.  (n,k,d) codes denote block codes with a minimum Hamming distance &#39;d&#39;. Code rate = k/n.</p>
<p><em>Linear codes</em> require that the sum of any two codewords is also a codeword.  The all-zeros codeword exists in any linear code. The minimum Hamming distance of a linear block code equals the smallest non-zero codeword&#39;s weight (number of 1s).  <em>Binary linear codes</em> use modulo-2 arithmetic (Galois Field F2).</p>
<h3 id="rectangular-parity-sec-code">Rectangular Parity SEC Code</h3>
<p><em>Parity</em> is the modulo-2 sum of bits. <em>Even parity code</em> adds a parity bit to each message, making the codeword have even parity. This detects single errors (HD=2).</p>
<p>The <em>rectangular parity code</em> arranges k bits into an r x c array and adds row and column parities. Codeword: message + row parities + column parities. Length: n = rc + r + c. This code is an SEC code (HD=3).  Decoding involves checking row and column parities and correcting the corresponding bit if both parities indicate an error.</p>
<h3 id="how-many-parity-bits-are-needed-in-an-sec-code-">How many parity bits are needed in an SEC code?</h3>
<p>Any linear code can be converted to a <em>systematic code</em> (message bits followed by parity bits). For SEC, the number of parity combinations (2^(n-k)) must be greater than or equal to the number of correctable situations (n+1):</p>
<p>n + 1 ‚â§ 2^(n-k)     (5.6)</p>
<p>Parity bit count grows at least logarithmically with message bits.</p>
<h3 id="hamming-codes">Hamming Codes</h3>
<p><em>Hamming codes</em> are efficient SEC codes with logarithmic parity bit growth.  Each parity bit protects multiple data bits, and single errors produce unique parity error combinations.</p>
<p><em>Syndrome bits (Ei)</em> are computed at the receiver by checking parities. The combination of syndrome bits indicates the erroneous bit (if any).</p>
<h4 id="is-there-a-logic-to-the-hamming-code-construction-">Is There a Logic to the Hamming Code Construction?</h4>
<p>Hamming code construction:</p>
<ol>
<li>Assign parity bits to indices that are powers of 2 (1, 2, 4, 8,...).</li>
<li>Assign data bits to remaining indices.</li>
<li>Data bit <em>di</em> is included in the parity computation for <em>pj</em> if and only if index(<em>pj</em>) contributes to index(<em>di</em>) in binary representation (bitwise AND is non-zero).</li>
</ol>
<p>The syndrome bits (E3E2E1 in the (7,4) example) treated as a binary number give the index of the bit to correct.</p>
<p><strong>Note: This is just the information, one needs for Web Development. For Sysops, the networks and their fundamentals are a two-semester course.</strong></p>
             
        </main>
    </div>

    <footer>
        <div class="container">
            <p>Made with love by Kavya Sahai</p>
        </div>
    </footer>
    <script src="../script.js"></script>
      <script>
          document.addEventListener('DOMContentLoaded', function () {
              const toc = document.getElementById('toc');
              const headings = document.querySelectorAll('.blog-content h2, .blog-content h3');

              if (!headings || !toc) {
                return;
             }
             headings.forEach((heading, index) => {
                const id = `heading-${index + 1}`;
                heading.id = id;

                const li = document.createElement('li');
                 const a = document.createElement('a');
                   a.href = `#${id}`;
                 a.textContent = heading.textContent;

                li.appendChild(a);
                toc.appendChild(li);
             });
           });

      </script>
</body>
</html>